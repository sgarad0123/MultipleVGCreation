trigger: none

pool:
  name: AKS
  vmImage: 'ubuntu-latest'

variables:
  - group: vg-create-vg-source
  - group: devops-secrets-vg

parameters:
  - name: environments
    type: object
    default: ['DEV', 'SIT', 'UAT', 'PT', 'PROD', 'DR'] # Correct way to define default object/array

steps:
  - task: Bash@3
    displayName: "üîß Generate export-vars.sh"
    inputs:
      targetType: 'inline'
      script: |
        echo "üîß Generating export-vars.sh..."
        cat <<EOF > export-vars.sh
        #!/bin/bash
        export ORG="${ORG}"
        export PROJECT="${PROJECT}"
        export AZURE_DEVOPS_PAT="${AZURE_DEVOPS_PAT}"
        export TRACKCOUNT=1
        export track1_name="${track1_name}"
        export track1_type="${track1_type}"
        export track1_appid="${track1_appid}"
        export track1_apptype="${track1_apptype}"
        EOF
        chmod +x export-vars.sh
        echo "‚úÖ export-vars.sh created"

  - task: Bash@3
    displayName: "üîê Make create-multi-env-vgs.sh Executable"
    inputs:
      targetType: 'inline'
      script: |
        chmod +x ./create-multi-env-vgs.sh

  - task: Bash@3
    displayName: "üöÄ Create Variable Groups"
    inputs:
      targetType: 'inline'
      script: |
        source ./export-vars.sh

        # Correctly access the pipeline parameter for environments
        # Azure DevOps injects object parameters as JSON. We need to parse it.
        # A common way is to convert the YAML parameter list to a Bash array.

        # Convert the space-separated string from the parameter into a Bash array
        # This approach assumes the parameter comes as a space-separated string if used directly
        # If the parameter is an actual YAML array, Azure DevOps often converts it to a
        # space-separated string when accessed in a Bash script like this.
        # For robustness, especially with YAML 'object' type parameters, it's safer
        # to explicitly handle the JSON output.

        # Let's use a more robust way to handle the parameters.environments object,
        # treating it as a space-separated string from Azure DevOps injection.
        # This approach is generally safe for simple string arrays like your environments.

        # Convert the parameter object to a string, then parse into a bash array
        # Azure DevOps typically provides 'object' parameters as a space-separated string in Bash scripts.
        # So, "${{ parameters.environments }}" might evaluate to "DEV SIT UAT PT PROD DR" directly.
        # We can then split this string into a bash array.

        # IMPORTANT: Azure DevOps passes `object` parameters as a JSON string to a Bash script.
        # To handle this robustly, you need to parse the JSON.
        # However, for simple string arrays like ['DEV', 'SIT', ...], Azure DevOps often
        # provides it as a space-separated string when you access it directly like below.
        # If it were a more complex object, you'd need 'jq' to parse JSON.

        # For your simple string array, this is generally sufficient and common practice:
        ENVIRONMENTS_LIST="${{ parameters.environments }}"
        IFS=' ' read -r -a environments_array <<< "$ENVIRONMENTS_LIST"

        echo "üîÅ Environments to process: ${environments_array[@]}"

        trackname="${track1_name}"
        tracktype="${track1_type}"
        appid="${track1_appid}"
        apptype="${track1_apptype}"

        if [[ -z "$trackname" || -z "$tracktype" || -z "$appid" || -z "$apptype" ]]; then
          echo "‚ùå ERROR: Missing input for track1"
          exit 1
        fi

        echo "üß© Track 1: name=$trackname, type=$tracktype, appid=$appid, apptype=$apptype"

        for env in "${environments_array[@]}"; do
          echo "‚û°Ô∏è Creating variable group for $env - $appid - $trackname"
          ./create-multi-env-vgs.sh "$env" "$appid" "$trackname" "$tracktype" "$apptype"
        done
